// PROBLEM DESCRIPTION:
// In a town there are N shops connected by bidirectional roads. Each shop has exactly one of four types:
// 0 – Book
// 1 – School
// 2 – Sports
// 3 – Stationery
// The town is represented as:
// shops – a list where shops[i] is the type of shop i
// roads – a list of pairs [a, b] meaning there is a bidirectional road between shop a and shop b

// OBJECTIVE:
// Implement int CountPaths(List<int> shops, List<List<int>> roads) method that returns the number of valid paths.

// VALID PATH DEFINITION:
// - It visits exactly one shop of each type (0, 1, 2, 3).
// - No shop is visited more than once.
// - It follows only existing roads.
// - The visiting order matters. Visiting the same four shops in a different order counts as a different path.
// - The path may start from any shop.

// CONSTRAINTS:
// 1 <= N <= 50
// 0 <= number of roads <= 200
// Roads are bidirectional
// No duplicate roads

// PERFORMANCE EXPECTATIONS (Senior+ level):
// .NET release mode, run outside debugger Test 8 result <= 50 ms and Test 9 result <= 30 ms.

using System.Diagnostics;

static int CountPaths(List<int> shops, List<int[]> roads)
{
    var adj = new Dictionary<int, List<int>>(shops.Count);

    for (int i = 0; i < shops.Count; i++)
    {
        adj.Add(i, new List<int>());
    }

    foreach (var road in roads)
    {
        int v = road[0];
        int u = road[1];

        adj[v].Add(u);
        adj[u].Add(v);
    }

    static int Calculate(
        int currentShop,
        List<int> shops,
        bool[] visitedShops,
        bool[] visitedTypes,
        Dictionary<int, List<int>> adjacentShops)
    {
        if (visitedTypes.All(x => x))
        {
            return 1;
        }

        var totalPaths = 0;

        for (int i = 0; i < adjacentShops[currentShop]?.Count; i++)
        {
            var neighbour = adjacentShops[currentShop][i];

            if (!visitedShops[neighbour] && !visitedTypes[shops[neighbour]])
            {
                visitedShops[neighbour] = true;
                visitedTypes[shops[neighbour]] = true;

                totalPaths += Calculate(
                    currentShop: neighbour,
                    shops: shops,
                    visitedShops: visitedShops,
                    visitedTypes: visitedTypes,
                    adjacentShops: adjacentShops);

                visitedShops[neighbour] = false;
                visitedTypes[shops[neighbour]] = false;
            }
        }

        return totalPaths;
    }

    var paths = 0;
    var visitedShops = new bool[shops.Count];
    var visitedTypes = new bool[4];

    for (int i = 0; i < shops.Count; i++)
    {
        visitedShops[i] = true;
        visitedTypes[shops[i]] = true;

        paths += Calculate(
            currentShop: i,
            shops: shops,
            visitedShops: visitedShops,
            visitedTypes: visitedTypes,
            adjacentShops: adj);

        Array.Clear(visitedShops, 0, visitedShops.Length);
        Array.Clear(visitedTypes, 0, visitedTypes.Length);
    }

    return paths;
}

Dictionary<string, (int[] ints, IReadOnlyList<int[]> roads, int expected)> TestCases = new()
{
    {
        "1_Minimal valid case",
        (new int[] { 0, 1, 2, 3 },
        new List<int[]>
        {
            new int[2] { 0, 1 },
            new int[2] { 1, 2 },
            new int[2] { 2, 3 }
        }, 2)
    },
    {
        "2_Missing type",
        (new int[] { 0, 1, 2, 2},
        new List<int[]>
        {
            new int[2] { 0, 1 },
            new int[2] { 1, 2 },
            new int[2] { 2, 3 }
        }, 0)
    },
    {
        "3_Multiple repeated types",
        (new int[] { 0, 1, 0, 2, 3 },
        new List<int[]>
        {
            new int[2] { 0, 1 },
            new int[2] { 1, 2 },
            new int[2] { 1, 3 },
            new int[2] { 3, 4 },
        }, 4)
    },
    {
        "4_Star graph",
        (new int[] { 0, 1, 2, 3 },
        new List<int[]>
        {
            new int[2] { 0, 1 },
            new int[2] { 0, 2 },
            new int[2] { 0, 3 },
        }, 0)
    },
    {
        "5_Full graph (4 nodes)",
        (new int[] { 0, 1, 2, 3 },
        new List<int[]>
        {
            new int[2] { 0, 1 },
            new int[2] { 0, 2 },
            new int[2] { 0, 3 },
            new int[2] { 1, 2 },
            new int[2] { 1, 3 },
            new int[2] { 2, 3 },
        }, 24)
    },
    {
        "6_Disconnected graph",
        (new int[] { 0, 1, 2, 3 },
        new List<int[]>
        {
            new int[2] { 0, 1 },
            new int[2] { 2, 3 },
        }, 0)
    },
    {
        "7_Cycle graph",
        (new int[] { 0, 1, 2, 3 },
        new List<int[]>
        {
            new int[2] { 0, 1 },
            new int[2] { 1, 2 },
            new int[2] { 2, 3 },
            new int[2] { 3, 0 },
        }, 8)
    },
    {
        // Performance test
        "8_Dense graph (20 nodes)",
        (Enumerable.Range(0,20).Select(i => i % 4).ToArray(), GenerateFullGraph(20), -1)
    },
    {
        // Performance test
        "9_Chain graph (50 nodes)",
        (Enumerable.Range(0,50).Select(i => i % 4).ToArray(), GenerateChainGraph(50), -1)
    }
};

static List<int[]> GenerateFullGraph(int n)
{
    var roads = new List<int[]>();
    for (int i = 0; i < n; i++)
    {
        for (int j = i + 1; j < n; j++)
        {
            roads.Add([i, j]);
        }
    }
    return roads;
}

static List<int[]> GenerateChainGraph(int n)
{
    var roads = new List<int[]>();
    for (int i = 0; i < n - 1; i++)
    {
        roads.Add([i, i + 1]);
    }
    return roads;
}

foreach (var test in TestCases)
{
    var (ints, roads, expected) = test.Value;

    var result = 0;

    if (expected == -1)
    {
        Stopwatch stopwatch = Stopwatch.StartNew();
        result = CountPaths(ints.ToList(), roads.ToList());
        stopwatch.Stop();

        var threshold = test.Key == "8_Dense graph (20 nodes)" ? 50 : 30;

        Console.WriteLine($"{test.Key}: Performance test: {result}." +
            $" Threshold: {threshold}. Execution time: {stopwatch.ElapsedMilliseconds}." +
            $" threshold exceeded: {stopwatch.ElapsedMilliseconds > threshold}.");
    }
    else
    {
        result = CountPaths(ints.ToList(), roads.ToList());
        Console.Write("{0, -30}", $"{test.Key}: ");
        Console.WriteLine($"{(result == expected ? "PASSED" : "FAILED")}. Expected: {expected}, got {result}.");
    }
}
